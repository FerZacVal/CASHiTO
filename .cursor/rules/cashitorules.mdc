---
name: CASHiTO
description: >
   Aplicación móvil financiera desarrollada en Kotlin con Jetpack Compose,que utiliza Firebase Authentication y Cloud Firestore como backend.
   La arquitectura es MVVM, separando claramente las capas de UI, lógica de negocio y acceso a datos.
   La aplicación permite a los usuarios llevar un control detallado de sus finanzas personales,
   gestionar gastos, establecer metas de ahorro y recibir recomendaciones con el apoyo de IA.

    Casos de uso (CU):
    - CU01 – Registrar gasto:
        El usuario ingresa un gasto especificando monto, categoría y fecha.
    - CU02 – Consultar gastos:
        El usuario visualiza la lista de gastos registrados, filtrados por fecha o categoría.
    - CU03 – Consultar detalle de gasto:
        El usuario accede a la información detallada de un gasto específico.
    - CU04 – Modificar gasto:
        El usuario actualiza la información de un gasto previamente registrado.
    - CU05 – Eliminar gasto:
        El usuario elimina un gasto de la lista.
    - CU06 – Registrar categoría personalizada:
        El usuario define una categoría de gasto propia además de las predefinidas.
    - CU07 – Consultar categorías de gasto:
        El usuario visualiza todas las categorías disponibles.
    - CU08 – Modificar categoría de gasto:
        El usuario actualiza el nombre o atributos de una categoría personalizada.
    - CU09 – Eliminar categoría de gasto:
        El usuario elimina una categoría personalizada creada previamente.
    - CU10 – Buscar gasto:
        El usuario localiza un gasto específico mediante búsqueda por nombre, monto o etiqueta.
    - CU11 – Registrar meta de ahorro:
        El usuario define un objetivo de ahorro indicando monto y fecha límite.
    - CU12 – Consultar metas de ahorro:
        El usuario visualiza todas las metas de ahorro creadas.
    - CU13 – Consultar detalle de meta de ahorro:
        El usuario accede al detalle de una meta específica (monto, plazo, progreso).
    - CU14 – Modificar meta de ahorro:
        El usuario actualiza los datos de una meta de ahorro existente.
    - CU15 – Eliminar meta de ahorro:
        El usuario elimina una meta de ahorro previamente registrada.
    - CU16 – Consultar progreso de meta de ahorro:
        El usuario visualiza el estado de avance de sus metas en porcentaje o monto acumulado.
    - CU17 – Recibir notificación de meta próxima a vencer:
        El sistema notifica al usuario cuando una meta de ahorro está cerca de su fecha límite.
    - CU18 – Recibir notificación de meta alcanzada:
        El sistema notifica al usuario cuando ha cumplido exitosamente una meta de ahorro.
    - CU19 – Generar reporte financiero:
        El sistema genera automáticamente un reporte con resúmenes de ingresos, egresos y tendencias.
    - CU20 – Consultar reporte financiero:
        El usuario accede a los reportes disponibles para analizar su situación financiera.
    - CU21 – Descargar reporte financiero:
        El usuario exporta el reporte en formato PDF o Excel.
    - CU22 – Compartir reporte financiero:
        El usuario comparte el reporte mediante correo electrónico u otras aplicaciones.
    - CU23 – Obtener recomendaciones de ahorro con IA:
        El sistema analiza los hábitos de gasto y propone estrategias personalizadas de ahorro.
    - CU24 – Consultar recomendaciones de ahorro:
        El usuario visualiza las recomendaciones generadas por el sistema de IA.
    - CU25 – Valorar recomendación de ahorro:
        El usuario marca una recomendación como útil o no útil para mejorar futuras sugerencias.
    - CU26 – Recibir notificación de nueva recomendación:
        El sistema envía notificaciones cuando se generan nuevas sugerencias de ahorro.

rules:
  - Usar Kotlin como lenguaje principal de programación.
  - Usar Jetpack Compose para construir la interfaz de usuario con un enfoque declarativo.
  - Seguir la arquitectura MVVM:
      * Vista (Capa UI): Composables que muestran y reaccionan al estado.
      * ViewModel (Capa Lógica): Maneja los estados y coordina llamadas a repositorios.
      * Modelo/Repositorio (Capa de Datos): Interactúa con Firebase Firestore y Authentication.
  - Usar Firebase Authentication para el inicio de sesión y registro de usuarios (correo/contraseña, Google sign-in).
  - Almacenar la información específica de cada usuario en Firestore bajo `/users/{userId}`:
      * `/users/{userId}/expenses/{expenseId}`
      * `/users/{userId}/savings_goals/{goalId}`
      * `/users/{userId}/reports/{reportId}`
  - Aplicar Reglas de Seguridad de Firestore:
      * Solo los usuarios autenticados pueden acceder a la base de datos.
      * Cada usuario solo puede leer y escribir sus propios documentos (`request.auth.uid == userId`).
      * Los reportes son de solo lectura (generados por el sistema).
  - Usar Coroutines y Flow de Kotlin para el manejo asincrónico de datos.
  - Gestionar el estado de la interfaz con `State` y `StateFlow`.
  - Seguir principios de código limpio: interfaces para repositorios, inyección de dependencias, modularidad.
  - Para llamadas a Firebase, usar el SDK de Firestore con funciones `suspend` integradas en el repositorio.
  - Centralizar validaciones y manejo de errores en el ViewModel.
  - La app debe diseñarse con enfoque en: responsividad, accesibilidad y buena experiencia de usuario (incluyendo temas claro/oscuro).
  - Siempre que termines de generar codigo, compilalo para ver que no hay problemas. Para ello utiliza compileKotlinDebug.
  - Aunque pienses que los build.gradle.kts esten incorrectos, los que tienes ahora mismo sonv validos. Si tienes que modificar libs.versions o los ficheros gradle, simplemente añade lo nuevo que necesites y no modifiques lo que ya existe.
alwaysApply: true
---
